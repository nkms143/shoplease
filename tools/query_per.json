[
    {
        "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 7480d288-8846-4f4f-bec5-a190bbc4db5d\n-- date: 2026-01-12T06:58:10.676Z",
        "rolname": "postgres",
        "calls": 12,
        "mean_time": 192.743147166667,
        "min_time": 129.470098,
        "max_time": 222.741283,
        "total_time": 2312.917766,
        "rows_read": 1512,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 21.304754852923747,
        "index_advisor_result": null
    },
    {
        "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
        "rolname": "postgres",
        "calls": 36,
        "mean_time": 47.3061180833333,
        "min_time": 2.202796,
        "max_time": 301.788324,
        "total_time": 1703.020251,
        "rows_read": 2808,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 15.686865088968178,
        "index_advisor_result": null
    },
    {
        "query": "SELECT name FROM pg_timezone_names",
        "rolname": "authenticator",
        "calls": 2,
        "mean_time": 823.866562,
        "min_time": 815.684057,
        "max_time": 832.049067,
        "total_time": 1647.733124,
        "rows_read": 2388,
        "cache_hit_rate": "0",
        "prop_total_time": 15.177604143952175,
        "index_advisor_result": null
    },
    {
        "query": "with base as (\n          select\n            auth.rolname,\n            statements.query,\n            statements.calls,\n            statements.total_exec_time + statements.total_plan_time as total_time,\n            statements.min_exec_time + statements.min_plan_time as min_time,\n            statements.max_exec_time + statements.max_plan_time as max_time,\n            statements.mean_exec_time + statements.mean_plan_time as mean_time,\n            coalesce(statements.rows::numeric / nullif(statements.calls, $1), $2) as avg_rows,\n            statements.rows as rows_read,\n            statements.shared_blks_hit as debug_hit,\n            statements.shared_blks_read as debug_read,\n            case\n              when (statements.shared_blks_hit + statements.shared_blks_read) > $3\n              then (statements.shared_blks_hit::numeric * $4) /\n                   (statements.shared_blks_hit + statements.shared_blks_read)\n              else $5\n            end as cache_hit_rate,\n            coalesce(\n              ((statements.total_exec_time + statements.total_plan_time) /\n                nullif(sum(statements.total_exec_time + statements.total_plan_time) OVER(), $6)) *\n                $7,\n              $8\n            ) as prop_total_time\n          from pg_stat_statements as statements\n            inner join pg_authid as auth on statements.userid = auth.oid\n          \n          order by total_time desc\n          limit $9\n        ),\n        query_results as (\n          select\n            base.*,\n            case\n              when (lower(base.query) like $10 or lower(base.query) like $11)\n              then (\n                select json_build_object(\n                  $12, array_length(index_statements, $13) > $14,\n                  $15, startup_cost_before,\n                  $16, startup_cost_after,\n                  $17, total_cost_before,\n                  $18, total_cost_after,\n                  $19, index_statements\n                )\n                from index_advisor(base.query)\n              )\n              else $20\n            end as index_advisor_result\n          from base\n        )\n        select *\n        from query_results\n        \n        order by total_time desc\n        limit $21\n\n-- source: dashboard\n-- user: 7480d288-8846-4f4f-bec5-a190bbc4db5d\n-- date: 2026-01-06T14:03:15.169Z",
        "rolname": "postgres",
        "calls": 5,
        "mean_time": 153.8271546,
        "min_time": 38.717144,
        "max_time": 239.530308,
        "total_time": 769.135773,
        "rows_read": 76,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 7.084665669163703,
        "index_advisor_result": null
    },
    {
        "query": "select setting from pg_config where name = $1",
        "rolname": "supabase_admin",
        "calls": 1583,
        "mean_time": 0.450560229311435,
        "min_time": 0.047556,
        "max_time": 3.109108,
        "total_time": 713.236843000001,
        "rows_read": 1583,
        "cache_hit_rate": "0",
        "prop_total_time": 6.56976928257478,
        "index_advisor_result": null
    },
    {
        "query": "do $$\n    declare\n        tbl record;\n        seq_name text;\n        new_seq_name text;\n        archive_table_name text;\n    begin\n        -- No tables should be owned by the extension.\n        -- We want them to be included in logical backups\n        for tbl in\n            select c.relname as table_name\n            from pg_class c\n              join pg_depend d\n                on c.oid = d.objid\n              join pg_extension e\n                on d.refobjid = e.oid\n            where\n              c.relkind in ('r', 'p', 'u')\n              and e.extname = 'pgmq'\n              and (c.relname like 'q\\_%' or c.relname like 'a\\_%')\n        loop\n          execute format('\n            alter extension pgmq drop table pgmq.\"%s\";',\n            tbl.table_name\n          );\n        end loop;\n    end $$",
        "rolname": "supabase_admin",
        "calls": 11,
        "mean_time": 62.4663677272727,
        "min_time": 48.278511,
        "max_time": 72.621703,
        "total_time": 687.130045,
        "rows_read": 0,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 6.329294268909802,
        "index_advisor_result": null
    },
    {
        "query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
        "rolname": "supabase_auth_admin",
        "calls": 23,
        "mean_time": 14.6628257826087,
        "min_time": 0.215897,
        "max_time": 33.675053,
        "total_time": 337.244993,
        "rows_read": 23,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 3.106432060343725,
        "index_advisor_result": null
    },
    {
        "query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 7480d288-8846-4f4f-bec5-a190bbc4db5d\n-- date: 2026-01-06T14:06:09.714Z",
        "rolname": "postgres",
        "calls": 5,
        "mean_time": 65.7576478,
        "min_time": 64.456071,
        "max_time": 66.77103,
        "total_time": 328.788239,
        "rows_read": 205,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 3.028535183303833,
        "index_advisor_result": null
    },
    {
        "query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
        "rolname": "postgres",
        "calls": 15,
        "mean_time": 21.8659382666667,
        "min_time": 2.956621,
        "max_time": 87.151228,
        "total_time": 327.989074,
        "rows_read": 0,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 3.0211739123315926,
        "index_advisor_result": null
    },
    {
        "query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
        "rolname": "supabase_auth_admin",
        "calls": 24,
        "mean_time": 11.7852970416667,
        "min_time": 0.141692,
        "max_time": 29.395023,
        "total_time": 282.847129,
        "rows_read": 24,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 2.6053622972595987,
        "index_advisor_result": null
    },
    {
        "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
        "rolname": "postgres",
        "calls": 5,
        "mean_time": 54.674548,
        "min_time": 38.316234,
        "max_time": 65.355626,
        "total_time": 273.37274,
        "rows_read": 5,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 2.518091777748082,
        "index_advisor_result": null
    },
    {
        "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
        "rolname": "postgres",
        "calls": 30,
        "mean_time": 8.95571403333333,
        "min_time": 2.555168,
        "max_time": 56.12434,
        "total_time": 268.671421,
        "rows_read": 90,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 2.4747869745022615,
        "index_advisor_result": null
    },
    {
        "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
        "rolname": "postgres",
        "calls": 11,
        "mean_time": 18.3896756363636,
        "min_time": 6.972377,
        "max_time": 65.509458,
        "total_time": 202.286432,
        "rows_read": 56,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 1.8633013707555348,
        "index_advisor_result": null
    },
    {
        "query": "SELECT concat(conrelid::regclass, $1, conname) as fk\n    FROM   pg_constraint\n    WHERE  contype = $2\n    ORDER  BY 1 desc\n    LIMIT $3",
        "rolname": "supabase_admin",
        "calls": 11,
        "mean_time": 15.4474235454545,
        "min_time": 13.713711,
        "max_time": 16.63088,
        "total_time": 169.921659,
        "rows_read": 275,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 1.565182879570265,
        "index_advisor_result": null
    },
    {
        "query": "SELECT * FROM pgbouncer.get_auth($1)",
        "rolname": "pgbouncer",
        "calls": 37,
        "mean_time": 4.50132902702703,
        "min_time": 0.07487,
        "max_time": 34.185316,
        "total_time": 166.549174,
        "rows_read": 37,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 1.5341182359299417,
        "index_advisor_result": null
    },
    {
        "query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 7480d288-8846-4f4f-bec5-a190bbc4db5d\n-- date: 2026-01-06T14:03:43.439Z",
        "rolname": "postgres",
        "calls": 42,
        "mean_time": 3.51873526190476,
        "min_time": 1.126585,
        "max_time": 16.531399,
        "total_time": 147.786881,
        "rows_read": 378,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 1.3612949480812688,
        "index_advisor_result": null
    },
    {
        "query": "with top_queries as (\n  select\n    statements.query,\n    statements.calls,\n    statements.total_exec_time + statements.total_plan_time as total_time,\n    statements.mean_exec_time + statements.mean_plan_time as mean_time\n  from pg_stat_statements as statements\n    inner join pg_authid as auth on statements.userid = auth.oid\n  where \n    -- Filter for SELECT queries only (index_advisor only works with SELECT)\n    (lower(statements.query) like $1 or lower(statements.query) like $2)\n    -- Filter for queries involving our table (handles schema.table and just table references)\n    and (\n      lower(statements.query) like $3\n      or lower(statements.query) like $4\n      or lower(statements.query) like $5\n    )\n    -- Exclude system queries\n    and statements.query not like $6\n    and statements.query not like $7\n  order by statements.calls desc\n  limit $8\n)\nselect\n  tq.query,\n  tq.calls,\n  tq.total_time,\n  tq.mean_time,\n  coalesce(ia.index_statements, $9) as index_statements,\n  coalesce((ia.startup_cost_before)::numeric, $10) as startup_cost_before,\n  coalesce((ia.startup_cost_after)::numeric, $11) as startup_cost_after,\n  coalesce((ia.total_cost_before)::numeric, $12) as total_cost_before,\n  coalesce((ia.total_cost_after)::numeric, $13) as total_cost_after\nfrom top_queries tq\nleft join lateral (\n  select * from index_advisor(tq.query)\n) ia on $14",
        "rolname": "postgres",
        "calls": 6,
        "mean_time": 24.5932713333333,
        "min_time": 0.679137,
        "max_time": 53.882939,
        "total_time": 147.559628,
        "rows_read": 4,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 1.3592016745867406,
        "index_advisor_result": null
    },
    {
        "query": "with\n      tables as (SELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $2 THEN $3\n    WHEN c.relreplident = $4 THEN $5\n    WHEN c.relreplident = $6 THEN $7\n    ELSE $8\n  END AS replica_identity,\n  pg_total_relation_size(format($9, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($10, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $11) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $12\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      table_id,\n      jsonb_agg(_pk.*) as primary_keys\n    from (\n      select\n        n.nspname as schema,\n        c.relname as table_name,\n        a.attname as name,\n        c.oid :: int8 as table_id\n      from\n        pg_index i,\n        pg_class c,\n        pg_attribute a,\n        pg_namespace n\n      where\n        i.indrelid = c.oid\n        and c.relnamespace = n.oid\n        and a.attrelid = c.oid\n        and a.attnum = any (i.indkey)\n        and i.indisprimary\n    ) as _pk\n    group by table_id\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $13\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($14, $15)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $16)\n    OR has_table_privilege(\n      c.oid,\n      $17\n    )\n    OR has_any_column_privilege(c.oid, $18)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n),\n      columns as (-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $19 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $20\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $21 THEN CASE\n      WHEN bt.typelem <> $22 :: oid\n      AND bt.typlen = $23 THEN $24\n      WHEN nbt.nspname = $25 THEN format_type(t.typbasetype, $26)\n      ELSE $27\n    END\n    ELSE CASE\n      WHEN t.typelem <> $28 :: oid\n      AND t.typlen = $29 THEN $30\n      WHEN nt.nspname = $31 THEN format_type(a.atttypid, $32)\n      ELSE $33\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($34, $35) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $36 THEN $37\n    WHEN $38 THEN $39\n    ELSE $40\n  END AS identity_generation,\n  a.attgenerated IN ($41) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $42 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($43, $44)\n    OR c.relkind IN ($45, $46) AND pg_column_is_updatable(c.oid, a.attnum, $47)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $48\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$49] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $50 AND cardinality(conkey) = $51\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $53),\n        $54,\n        length(pg_get_constraintdef(pg_constraint.oid, $55)) - $56\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $59\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($60, $61, $62, $63, $64))\n  AND (\n    pg_has_role(c.relowner, $65)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $66\n    )\n  )\n)\n    select\n      *,\n      COALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $67\n) AS columns\n    from tables\nwhere schema in ($1)\n\n-- source: api\n-- user: 7480d288-8846-4f4f-bec5-a190bbc4db5d\n-- date: 2026-01-12T06:55:15.336Z",
        "rolname": "supabase_read_only_user",
        "calls": 2,
        "mean_time": 72.6173235,
        "min_time": 54.104573,
        "max_time": 91.130074,
        "total_time": 145.234647,
        "rows_read": 6,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 1.3377858028377119,
        "index_advisor_result": null
    },
    {
        "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
        "rolname": "authenticator",
        "calls": 2,
        "mean_time": 60.88547,
        "min_time": 50.749122,
        "max_time": 71.021818,
        "total_time": 121.77094,
        "rows_read": 4,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 1.1216568366789426,
        "index_advisor_result": null
    },
    {
        "query": "select set_config('search_path', $1, true), set_config($2, $3, true), set_config('role', $4, true), set_config('request.jwt.claims', $5, true), set_config('request.method', $6, true), set_config('request.path', $7, true), set_config('request.headers', $8, true), set_config('request.cookies', $9, true)",
        "rolname": "authenticated",
        "calls": 169,
        "mean_time": 0.610346781065089,
        "min_time": 0.021988,
        "max_time": 4.474655,
        "total_time": 103.148606,
        "rows_read": 169,
        "cache_hit_rate": "100.0000000000000000",
        "prop_total_time": 0.9501227395781177,
        "index_advisor_result": null
    }
]